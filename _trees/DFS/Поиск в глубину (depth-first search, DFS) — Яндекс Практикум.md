Спринт 2/12: Алгоритмы → Тема 8/9: Спринт VII → Урок 3/3

Поиск в глубину предполагает посещение вершины и её детей прежде, чем её братьев.

Это означает, что сначала мы посещаем корень дерева, потом первого его ребёнка, затем спускаемся вниз и так до последнего листа. По пути назад мы посещаем все оставшиеся соседние вершины в том же порядке.

Цифрами отмечен порядок, в котором каждая вершина должна быть посещена при реализации поиска в глубину:

![image](https://pictures.s3.yandex.net/resources/S7_06_1_1604001096.png)

_Порядок обхода вершин дерева при использовании DFS_

Если на каком-то шаге мы нашли искомое значение, поиск останавливается.

Запишем алгоритм поиска по дереву в глубину:

1.  Добавляем корневую вершину в стек для обхода `stack`.
2.  Берём вершину из стека, назовём её `X`.
3.  Посещаем вершину `X`, проверяя на равенство искомому значению.
4.  Если они равны, завершаем поиск успешно и возвращаем вершину.
5.  Если нет, добавляем в обратном порядке всех детей вершины `X` в стек.
6.  Если стек не пуст, продолжаем с пункта 2.
7.  Если стек пуст, поиск завершён неуспешно.

Но эффективнее и проще использовать рекурсивный алгоритм:

1.  Посещаем вершину `X`, проверяя на равенство искомому значению.
2.  Если они равны, завершаем поиск успешно и возвращаем вершину.
3.  В противном случае рекурсивно запускаем алгоритм на каждом ребёнке.

Такой метод обхода дерева в глубину называется **pre-order**. Существует еще два метода обхода в глубину: **post-order** и **in-order**.

В pre-order мы посещаем ноду в тот момент, когда первый раз приходим в неё. В post-order мы делаем это на обратном пути после обхода всех её потомков.

![image](https://pictures.s3.yandex.net/resources/S7_07_1604001121.png)

_Порядок обхода вершин дерева при использовании DFS post-order_

Для реализации метода post-order достаточно сделать третий пункт рекурсивного алгоритма первым:

1.  Рекурсивно запускаем алгоритм на каждом ребёнке.
2.  Посещаем вершину `X`, проверяя на равенство искомому значению.
3.  Если они равны, завершаем поиск успешно и возвращаем вершину.

В методе обхода в глубину in-order мы посещаем сначала всех потомков слева от вершины, затем саму вершину, а следом потомков справа от вершины.

Понятие левый и правый однозначно определены только для бинарных деревьев:

![image](https://pictures.s3.yandex.net/resources/S7_08_7_1612903617.png)

_Порядок обхода вершин бинарного дерева при использовании DFS in-order_

Обратите внимание на вершины E и C — мы обходим их сразу, ведь у них нет детей слева.

В других деревьях можно как угодно определять левых и правых детей. Например, можно считать левым только первого ребёнка, а остальных — правыми, или считать два первых ребёнка левыми, а остальных – правыми. Главное придерживаться единого подхода при обходе. В нашем случае будем считать первого ребёнка левым, а остальных — правыми. Обойдём дерево методом in-order:

![image](https://pictures.s3.yandex.net/resources/S7_09_1_1604001165.png)

_Порядок обхода вершин небинарного дерева при использовании DFS in-order_

Для реализации обхода методом in-order также переопределим алгоритм:

1.  Рекурсивно запускаем алгоритм на левом ребёнке.
2.  Посещаем вершину `X`, проверяя на равенство искомому значению.
3.  Если они равны, завершаем поиск успешно и возвращаем вершину.
4.  Если они не равны, рекурсивно запускаем алгоритм на правом ребёнке и проходим по шагам 2 и 3.

Для обхода графа нам так же, как и при поиске в ширину, нужно выбрать стартовую вершину и идти вглубь по смежным вершинам, отмечая их как посещённые. Делаем это до тех пор, пока непосещённых смежных вершин не останется. Затем возвращаемся на шаг назад.

![image](https://pictures.s3.yandex.net/resources/S7_10_1_1604001188.png)

_Порядок обхода вершин дерева при использовании DFS_

Зелёными линиями отмечен путь обхода. Граф, в отличие от дерева, можно обойти разными путями, ведь все смежные вершины равнозначны. Этот же граф мы могли обойти и другим путём:

![image](https://pictures.s3.yandex.net/resources/S7_11_1_1604001210.png)

_Порядок обхода вершин дерева при использовании DFS_

Алгоритм поиска по графу в глубину:

1.  Посещаем вершину `X`, проверяя на равенство искомому значению. Отмечаем её как посещённую.
2.  Если они равны, завершаем поиск успешно и возвращаем вершину.
3.  В противном случае рекурсивно запускаем алгоритм на каждой смежной непосещённой вершине.

Так же как в деревьях, мы можем посещать вершину сразу для pre-order или после посещения смежных вершин для post-order. Метод in-order к графу неприменим, ведь в этой структуре данных нельзя определить левые или правые вершины.

Сложность алгоритма поиска в глубину такая же, как и в ширину, и линейно зависит от количества вершин и рёбер – `O(v + e)`.

Использование BFS или DFS зависит от структуры дерева или графа.

Если в дереве каждая вершина имеет много дочерних вершин, то при использовании BFS нам придётся хранить много вершин в очереди, расходуя память. В этом случае лучше подойдёт поиск в глубину.

![image](https://pictures.s3.yandex.net/resources/S7_12_1604001231.png)

_Для широкого дерева лучше подойдёт DFS_

Наоборот, если дерево неширокое, но глубокое, нам потребуется много рекурсивных вызовов, прежде чем мы дойдём до листовой вершины. Эти вызовы нужно хранить на стеке вызовов. В этом случае лучше подойдёт поиск в ширину.

![image](https://pictures.s3.yandex.net/resources/S7_13_1_1604001253.png)

_Для глубокого дерева лучше подойдёт BFS_