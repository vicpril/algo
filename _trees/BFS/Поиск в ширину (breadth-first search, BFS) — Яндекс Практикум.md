Спринт 2/12: Алгоритмы → Тема 8/9: Спринт VII → Урок 2/3

Чтобы найти элемент в нелинейной структуре данных, нужно определить алгоритм, которым мы обойдём вершины. Причём каждая вершина должна быть посещена строго один раз. Методы обхода отличаются последовательностью посещения вершин.

Поиск в ширину предполагает посещение вершины и её братьев прежде, чем её потомков.

Для дерева ниже это означает, что поиск начинается с посещения корня дерева, затем всех его детей. Мы обходим дерево слой за слоем от корня к листьям. Цифрами отмечен порядок, в котором каждая вершина должна быть посещена при реализации поиска в ширину:

![image](https://pictures.s3.yandex.net/resources/S7_03_4_1606647300.png)

_Порядок обхода вершин дерева при использовании BFS_

Если на каком-то шаге мы нашли искомое значение, поиск останавливается.

Запишем алгоритм поиска по дереву в ширину:

1.  Добавляем корневую вершину в очередь для обхода `queue`.
2.  Берём вершину из очереди, назовём её `X`.
3.  Посещаем вершину `X`, проверяя на равенство искомому значению.
4.  Если они равны, завершаем поиск успешно и возвращаем вершину.
5.  Если нет, добавляем по порядку всех детей вершины `X` в очередь.
6.  Если очередь не пуста, продолжаем с пункта 2.
7.  Если очередь пуста, поиск завершён неуспешно.

У дерева есть направление и точка входа — корень дерева. Поэтому визуально понятно, что значит поиск в ширину. У графа нет корня, поэтому его обход начинается с любой вершины, которую мы примем за стартовую. Понятие ширины также не выражено явно, как у дерева. Поиск BFS в графе означает посещение смежных вершин прежде, чем посещение остальных.

Такой будет порядок посещения вершин графа при старте из вершины `А`:

![image](https://pictures.s3.yandex.net/resources/S7_04_3_1606647325.png)

_Порядок обхода вершин графа при использовании BFS_

В графе нет иерархии родитель-ребёнок и любые вершины могут быть связаны друг с другом. Поэтому нужно хранить информацию об посещённых вершинах, чтобы не посещать их несколько раз и не войти в цикл. Например, в графе на иллюстрации мы можем посетить `А`, потом смежную к ней `B`, затем опять смежную к ней `A` и так далее. Чтобы этого избежать, удобно использовать хеш-таблицу, где ключами будут ноды, а значения — `true` для посещённых вершин:

Запишем алгоритм поиска по графа в ширину:

1.  Добавляем стартовую вершину в очередь для обхода `queue`.
2.  Берём вершину из очереди `queue`, назовём её `X`.
3.  Посещаем вершину `X`, отмечая её посещённой в хеш-таблице `visited` и проверяя на равенство искомому значению.
4.  Если они равны, завершаем поиск успешно и возвращаем вершину.
5.  Если они не равны, добавляем по очереди все смежные к `X` и ещё непосещённые вершины в очередь `queue`.
6.  Если очередь не пуста, продолжаем с пункта 2.
7.  Если очередь пуста, поиск завершён неуспешно.

Если граф ориентированный или у него не все вершины соединены, то, начав с одной вершины, мы можем не обойти все остальные. Например, если мы начнём обход графа с вершины `А`, то обойдём лишь его часть:

![image](https://pictures.s3.yandex.net/resources/S7_05_3_1606647350.png)

_В ориентированном графе может потребоваться перезапуск поиска с другой вершины, т. к. не из каждой можно обойти весь граф. При старте из А вершины E и F остаются непосещёнными_

В таком случае обход нужно продолжить, приняв любую другую непосещённую вершину за стартовую.

Сложность алгоритма поиска в ширину линейно зависит от количества вершин и рёбер. В худшем случае для каждой вершины мы должны взять все её смежные вершины, число которых равно числу её рёбер, и вызвать алгоритм на каждой из вершин. Суммарная сложность равна `O(v + e)`, где `v` — количество вершин графа, а `e` — количество рёбер. У дерева невозможны произвольные связи между любыми нодами, и количество ребер всегда равно v-1, поэтому сложность для дерева будет `O(v)`.