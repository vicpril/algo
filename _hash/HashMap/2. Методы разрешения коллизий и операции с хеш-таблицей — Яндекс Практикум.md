Спринт 2/12: Алгоритмы → Тема 5/9: Спринт IV → Урок 2/3

## Методы разрешения коллизий и операции с хеш-таблицей

Два основных способа разрешения коллизий — метод последовательных проб и метод цепочек.

**В методе последовательных проб** мы ищем первую свободную ячейку после текущей, и записываем пару ключ-значение в неё:

![image](https://pictures.s3.yandex.net/resources/S4_04.4_03_hash_1593508088.png)

_Решение коллизий методом последовательных проб_

Здесь хеш ключа `Bob` — `3`, но такая ячейка уже занята. Тогда продвигаемся вперёд, пока не найдём свободную ячейку. Поиск значения по ключу происходит так же — мы двигаемся от ячейки `3` вперёд, пока не найдём ячейку с ключом как `Bob`.

Недостаток метода последовательных проб в том, записей должно быть не больше, чем вмещает хеш-таблица.

**В методе цепочек** каждая ячейка может хранить несколько пар. Для этого мы используем любую другую линейную структуру данных. Например, массив или связанный список:

![image](https://pictures.s3.yandex.net/resources/S4_04.4_04_hash_1593508132.png)

_Решение коллизий методом цепочек_

Новую пару `Bob, 200` мы добавили в конец списка ячейки `3`. При поиске значения по ключу `Bob`, будем искать ключ в списке ячейки `3`.

Недостаток метода цепочек в том, что дополнительные структуры данных имеют свою сложность. Например, на схеме выше мы использовали связанный список. Поэтому поиск элемента по ключу там имеет линейную сложность.

Но в отличие от метода последовательных проб, количество данных не ограничено размером хеш-таблицы.

Правда, если число хранимых данных сильно больше хеш-таблицы, структура данных становится бесполезной. Ведь придётся часто линейно искать по ключу внутри ячейки, а это снизит скорость доступа к данным.

В таком случае стоит увеличить хеш-таблицу: рассчитать хеши всех ключей заново и перераспределить все элементы. Обычно размер хеш-таблицы на треть больше, чем максимальное число ключей в ней.

## Операции с хеш-таблицей

В базовом случае операции добавления элемента, поиска по ключу и удаления элемента занимают `О(1)`. Хеширующая функция, как важная часть хеш-таблицы, также работает за `О(1)`. По хешу мы знаем адрес памяти, и если нет коллизий, сразу возвращаем нужный элемент.

Если таблица сильно заполнена, сложность поиска и удаления ухудшается. Ведь нужно линейно пройти по вложенной структуре данных внутри ячейки. А в отдельных случаях нужно расширить таблицу. Это влечёт перехеширование всех её данных и размещение их в новой области памяти. Поэтому в худшем случае все операции занимают `О(n)` времени.

В отличие от всех рассмотренных структур данных, хеш-таблица не поддерживает операцию произвольного доступа к элементам.

Пространственная сложность хеш-таблицы `О(n)`. Объём памяти, нужный для реализации этой структуры данных, линейно зависит от количества хранимых элементов.

![image](https://pictures.s3.yandex.net/resources/S4_04.4_05_table_1593508175.png)