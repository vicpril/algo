Спринт 2/12: Алгоритмы → Тема 4/9: Спринт III → Урок 3/4

## Сортировка слиянием

Это последний урок из большой темы алгоритмов сортировки. Из него вы узнаете, как работает сортировка слиянием (merge sort).

Сортировка слиянием похожа на быструю сортировку, которую вы изучили в прошлом уроке. Оба алгоритма рекурсивные. Только в сортировке слиянием мы не выделяем опорный элемент, а просто разбиваем массив на две части. Затем сортируем каждую отдельно этим же алгоритмом и соединяем два отсортированных массива в один. Условие остановки рекурсии –– сортировка массива из одного или нуля элементов.

Для массива `[6,5,3,1,8,7,2,4]` сортировка слиянием происходит так:

![_Работа сортировки слиянием_](./1_S1_03_01_video_sliyanie_2_1.gif)

Запишем алгоритм сортировки слиянием `mergeSort(arr, start, end, buffer)`:

1.  Принимаем на вход массив `arr` и индексы начала и конца участка `start` и `end`, который нужно отсортировать. При первом запуске они будут `0` и `arr.length - 1`. Массив-буфер `buffer` по умолчанию не определён.
2.  Если `end ≤ start`, выходим из алгоритма и возвращаем входной массив. Сортировать нечего.
3.  Если буфер не определён, создадим его копией входного массива. Это потребуется только на первом вызове.
4.  Определяем середину массива: `mid = Math.floor((start + end) / 2);`.
5.  Вызываем сортировку левого и правого участков массива: `mergeSort(arr, start, mid, buffer)` и `mergeSort(arr, mid + 1, end, buffer)`.
6.  Совмещаем результаты отсортированных правой и левой частей:
    
    6.1 Копируем значения из `arr` на отрезке от `start` до `end` в `buffer`. Сделав массив `buffer` в самом начале сортировки, мы сэкономили память. В противном случае, чтобы совместить два результата, на каждом шаге потребовалось бы создать две дополнительные копии `arr` на участках от `start` до `mid` и от `mid+1` до `end`.
    
    6.2 Создаём: две переменные, чтобы отследить индексом левую и правую части — `l = start` и `r = mid + 1`; переменную, чтобы отследить текущую позицию — `i = start`.
    
    6.3 Пока `l < mid + 1` и `r < end + 1`, сравниваем значения `buffer[l]` и `buffer[r]`.
    
    6.3.1 Если `buffer[l] <= buffer[r]`, присваиваем `arr[i]` значение `buffer[l]`, инкрементируем `l` и `i`.
    
    6.3.2 В противном случае присваиваем `arr[i]` значение `buffer[r]`, инкрементируем `r` и `i`.
    
    6.4 Пока `l < mid + 1`, присваиваем `arr[i]` значение `buffer[l]`, инкрементируем `l` и `i`.
    
    6.5 Пока `r < end + 1`, присваиваем `arr[i]` значение `buffer[r]`, инкрементируем `r` и `i`.
    
7.  Возвращаем отсортированный массив `arr`.
    

### Анализ сложности

Так выглядит дерево решения для алгоритма сортировки слиянием:

![image](https://pictures.s3.yandex.net/resources/S1_03_12_sliyanie_1588266674.png)

_Дерево решения для сортировки слиянием_

На каждом шаге мы уменьшаем массив в два раза. Чтобы объединить результат на каждом уровне, выполняем `О(n)` операций. Суммарная сложность в худшем случае `О(n * log(n))`.

Поскольку мы всегда делим массив на равные части, сложность в базовом и лучшем случаях одинаковая — `Ω(n * log(n))` и `Θ(n * log(n))`.

Пространственная сложность алгоритма `О(n)`. Он также создаёт `log(n)` записей в стеке вызовов, как и быстрая сортировка, но дополнительно требует создания копии исходного массива. А для этого нужно еще `О(n)` памяти. Общая сложность `О(n + log(n)) = О(n)`.

## Комбинации из алгоритмов

В некоторых программах используют комбинацию из алгоритмов. Это зависит от характера и размера входных данных. Например, мы можем алгоритмом `quickSort` отсортировать подмассивы внутри алгоритма `mergeSort`, и наоборот. Для сортировки небольших массивов лучше применять простые алгоритмы. Например, `insertionSort` даже с худшей сложностью даст лучший результат.